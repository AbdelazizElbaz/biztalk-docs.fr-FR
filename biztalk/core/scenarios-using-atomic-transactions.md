---
title: "Scénarios à l’aide de Transactions atomiques | Documents Microsoft"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- Scope shape [Orchestration Designer], examples
- Scope shape [Orchestration Designer], atomic transactions
- transactions, examples
- transactions, atomic
- atomic transactions, examples
- examples, atomic transactions
ms.assetid: f3481b4e-7e7e-47f0-b8f4-6012a2fc5310
caps.latest.revision: "4"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: e73cfea7a99e2fafbf115a367dbf0840de3369c3
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/20/2017
---
# <a name="scenarios-using-atomic-transactions"></a><span data-ttu-id="5440a-102">Utilisation de transactions atomiques</span><span class="sxs-lookup"><span data-stu-id="5440a-102">Scenarios Using Atomic Transactions</span></span>
<span data-ttu-id="5440a-103">Les scénarios suivants décrivent l'utilisation des transactions atomiques.</span><span class="sxs-lookup"><span data-stu-id="5440a-103">The following scenarios describe the use of atomic transactions.</span></span>  
  
## <a name="scenario-1-an-atomic-transaction-with-com-servicedcomponent"></a><span data-ttu-id="5440a-104">Scénario 1 : Une Transaction atomique avec COM + ServicedComponent</span><span class="sxs-lookup"><span data-stu-id="5440a-104">Scenario 1: An Atomic Transaction with COM+ ServicedComponent</span></span>  
 <span data-ttu-id="5440a-105">L’orchestration suivante montre comment utiliser le **RetryTransactionException** avec des transactions atomiques.</span><span class="sxs-lookup"><span data-stu-id="5440a-105">The following orchestration shows how to use the **RetryTransactionException** with atomic transactions.</span></span> <span data-ttu-id="5440a-106">Bien qu'il ne soit pas possible d'inclure directement des gestionnaires d'exceptions dans une étendue atomique, cette étendue peut comporter une étendue non transactionnelle possédant un gestionnaire d'exceptions.</span><span class="sxs-lookup"><span data-stu-id="5440a-106">Although exception handlers cannot be directly included for an atomic scope, the scope can include a non-transactional scope that can have an exception handler.</span></span> <span data-ttu-id="5440a-107">Le **ServicedComponent** s’inscrit dans la même transaction DTC et toute exception générée par le composant est interceptée et levée à nouveau en tant que **RetryTransactionException**.</span><span class="sxs-lookup"><span data-stu-id="5440a-107">The **ServicedComponent** enlists in the same DTC transaction and any exception raised by the component is caught and re-thrown as **RetryTransactionException**.</span></span> <span data-ttu-id="5440a-108">(Cela suppose que le **réessayer** est définie sur **True** pour l’étendue atomique).</span><span class="sxs-lookup"><span data-stu-id="5440a-108">(This assumes that the **Retry** property is set to **True** for the atomic scope).</span></span>  
  
 <span data-ttu-id="5440a-109">Notez que l’orchestration aurait été suspendue et l’action de la forme MessageAssignment aurait ont été restaurée même si le **RetryTransactionException** n’est pas levée.</span><span class="sxs-lookup"><span data-stu-id="5440a-109">Note that the orchestration would have been suspended and the action in the MessageAssignment shape would have been rolled back even if the **RetryTransactionException** is not thrown.</span></span> <span data-ttu-id="5440a-110">Ce modèle, toutefois, permet de renforcer la faculté de récupération de l'application dans laquelle les nouvelles tentatives ont lieu de façon automatique.</span><span class="sxs-lookup"><span data-stu-id="5440a-110">This pattern, however, allows building resilience in the application where the retries occur automatically.</span></span>  
  
 <span data-ttu-id="5440a-111">**Une transaction atomique avec COM + ServicedComponent**</span><span class="sxs-lookup"><span data-stu-id="5440a-111">**An atomic transaction with COM+ ServicedComponent**</span></span>  
  
 <span data-ttu-id="5440a-112">![Une transaction atomique avec COM &#43; ServicedComponent](../core/media/bts-trans-orch-fig5.gif "BTS_Trans_Orch_Fig5")</span><span class="sxs-lookup"><span data-stu-id="5440a-112">![An atomic transaction with COM&#43; ServicedComponent](../core/media/bts-trans-orch-fig5.gif "BTS_Trans_Orch_Fig5")</span></span>  
  
## <a name="scenario-2-using-transacted-adapters-with-atomic-transactions"></a><span data-ttu-id="5440a-113">Scénario 2 : Utilisation d’adaptateurs traités avec des Transactions atomiques</span><span class="sxs-lookup"><span data-stu-id="5440a-113">Scenario 2: Using Transacted Adapters with Atomic Transactions</span></span>  
 <span data-ttu-id="5440a-114">L'orchestration suivante montre comment utiliser les transactions atomiques avec l'adaptateur SQL.</span><span class="sxs-lookup"><span data-stu-id="5440a-114">The following orchestration shows how to use the atomic transactions with the SQL adapter.</span></span> <span data-ttu-id="5440a-115">L’ensemble de l’orchestration est marqué comme à long terme avec transactions atomiques individuelles pour les deux éléments de travail logiques : insertion d’un nouveau client et le même ordre d’insertion des détails pour le client.</span><span class="sxs-lookup"><span data-stu-id="5440a-115">The whole orchestration is marked as long running with individual atomic transactions for the two logical pieces of work: Inserting a new Customer and Insert Order details for the customer.</span></span>  
  
 <span data-ttu-id="5440a-116">Si, pour une raison ou pour une autre, l'insertion de la commande (Order Insert) échoue, l'insertion du client (Customer Insert) doit être annulée.</span><span class="sxs-lookup"><span data-stu-id="5440a-116">If, for whatever reason, the Order Insert fails, the Customer Insert should be rolled back.</span></span> <span data-ttu-id="5440a-117">L'exemple utilise l'adaptateur SQL pour faire le travail de la base de données.</span><span class="sxs-lookup"><span data-stu-id="5440a-117">The sample uses the SQL adapter to do the database work.</span></span> <span data-ttu-id="5440a-118">Comme nous l'avons déjà vu, l'étendue associée à une transaction atomique se termine lorsque le message est envoyé à la base de données MessageBox.</span><span class="sxs-lookup"><span data-stu-id="5440a-118">As mentioned earlier, the scope associated with an atomic transaction completes when the message is sent to the MessageBox database.</span></span> <span data-ttu-id="5440a-119">Cela implique qu'une fois que le moteur a réussi à envoyer le message dans les étendues Scope_InsertCustomer et Scope_InsertOrder, chaque étendue est validée.</span><span class="sxs-lookup"><span data-stu-id="5440a-119">This implies that after the engine is successful in sending the message in the Scope_InsertCustomer and Scope_InsertOrder scopes, each one of the scopes commits.</span></span> <span data-ttu-id="5440a-120">L'adaptateur SQL crée une transaction pour l'insertion du client ou la commande.</span><span class="sxs-lookup"><span data-stu-id="5440a-120">The SQL adapter creates a new transaction for the actual Insert of the Customer or the order.</span></span>  
  
 <span data-ttu-id="5440a-121">Les ports présentent une propriété « Notification d'envoi » pour valider l'envoi du message par le biais du port d'envoi.</span><span class="sxs-lookup"><span data-stu-id="5440a-121">The Ports have a property “Delivery Notification” for validating that the message has been successfully sent via the Sent Port.</span></span> <span data-ttu-id="5440a-122">Lorsque la propriété Notification d'envoi est définie sur « Transmis », un abonnement de réception est placé avant le point de validation transactionnel de l'opération d'envoi.</span><span class="sxs-lookup"><span data-stu-id="5440a-122">When the Delivery Notification property is set to “Transmitted”, a receive subscription is placed before the Transactional commit point of the Send Operation.</span></span> <span data-ttu-id="5440a-123">Cependant, dans le cas d'étendues atomiques, l'abonnement de réception est placé dans l'étendue parente englobante.</span><span class="sxs-lookup"><span data-stu-id="5440a-123">However, in case of Atomic Scopes, the receive subscription is placed in the enclosing Parent scope.</span></span>  
  
 <span data-ttu-id="5440a-124">Si la transaction SQL InsertOrder échoue, un accusé de réception négatif (ou nack) est renvoyé et la « Scope_InsertOrder » est validée.</span><span class="sxs-lookup"><span data-stu-id="5440a-124">In the scenario where the InsertOrder SQL transaction fails, a "Nack" will be sent back and the "Scope_InsertOrder" commits.</span></span> <span data-ttu-id="5440a-125">Une fois que le port d'envoi a épuisé toutes les tentatives configurées, une exception DeliveryFailureException est générée.</span><span class="sxs-lookup"><span data-stu-id="5440a-125">After the Sent Port exhausts the configured retries, a DeliveryFailureException will be raised.</span></span> <span data-ttu-id="5440a-126">Cette exception est détectée par le gestionnaire d'exceptions par défaut, qui exécute le processus de compensation par défaut.</span><span class="sxs-lookup"><span data-stu-id="5440a-126">This exception will be caught by the default exception handler, which will run the default compensation process.</span></span> <span data-ttu-id="5440a-127">Les gestionnaires de compensation associés à Scope_InsertCustomer et Scope_InsertOrder sont alors appelés, ce qui annule l'insertion des informations sur le client.</span><span class="sxs-lookup"><span data-stu-id="5440a-127">This will invoke the compensation handlers associated with the Scope_InsertCustomer and Scope_InsertOrder, causing the undo operation of inserting the customer information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5440a-128">L'imbrication des deux étendues en une étendue à long terme et l'appel de la forme Compenser (qui cible la transaction à long terme) à partir du gestionnaire d'exceptions pour l'étendue à long terme aboutissent au résultat décrit ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="5440a-128">Nesting the two scopes in a long running scope and invoking the Compensate shape (targeting the long running transaction) from the exception handler for the long running scope will result in the same behavior as described above.</span></span> <span data-ttu-id="5440a-129">L'ensemble de l'orchestration ne peut pas être indiqué comme étant atomique car les transactions atomiques n'autorisent pas les transactions imbriquées.</span><span class="sxs-lookup"><span data-stu-id="5440a-129">The whole orchestration could not be marked atomic as atomic transactions do not allow nested transactions.</span></span>  
  
 <span data-ttu-id="5440a-130">**Adaptateurs traités avec des transactions atomiques**</span><span class="sxs-lookup"><span data-stu-id="5440a-130">**Transacted adapters with atomic transactions**</span></span>  
  
 <span data-ttu-id="5440a-131">![Transactionnel des cartes avec des transactions atomiques](../core/media/bts-trans-orch-fig6.gif "BTS_Trans_Orch_Fig6")</span><span class="sxs-lookup"><span data-stu-id="5440a-131">![Transacted adapters with atomic transactions](../core/media/bts-trans-orch-fig6.gif "BTS_Trans_Orch_Fig6")</span></span>